---
name: InlineEdit
menu: Components
route: /components/inline-edit
showDirectoryLink: true
---

import { Playground, Props } from "docz";
import { InlineEdit } from ".";

# Inline Edit

```ts
import { InlineEdit } from "@jobber/components/InlineEdit";
```

<Playground>
  <InlineEdit text="Bob" />
</Playground>

<!--
  INTERFACE: This is for the proposal stage of the component

  Provide an example of what the component looks like in code. How would you use
  it from another React component? This should consist primarily of code blocks.
  This section can be deleted once the component is built, when the Playground
  will demonstrate this at a higher fidelity.
-->

[coming soon]

## Props

<Props of={InlineEdit} />

<!--
  It is not necessary to provide an example of each prop. Use usage examples to
  highlight key features of a component or particular considerations.

  See `Button.mdx` for a good example of this.
-->

[coming soon]

## Usage Guidelines

<!--
  What is the design purpose of this component? How do its responsibilities
  relate to other components? What should this component not be used for? What
  are some related components in Atlantis? Try to describe this component not
  in terms of what it looks like or what elements make it up, but what function
  it performs or how it enables a user to perform tasks (e.g. “Buttons allow users
  to initiate, complete, and reverse actions.” vs “Buttons are rectangular elements
  that have a green background and white text”).
-->

The `<InlineEdit>` will be used to switch between displaying a value and displaying the component to update or change the value. The user can interact with a single data point in a **read** state that transforms into an input field for **edit** state, with an associated **save** and **cancel** action to update that one piece of data. 

InlineEdit will be used for modifying a single piece of data/information that could be presented as content on its own or may have a default setting. It will have two states a **read** and an **edit** state. The **read** state will show as clearly editable data field with an 'edit’ icon next to data. The **show** state will have a small input and a way to ‘cancel’ any changes made to the data.

Scenarios where InlineEdit should not be used include the following:
- Should not be used inside of a modal 
- Should not be used to replace **forms** as a primary means of data entry (e.g. first time create) 
- Should not be used with an Input Group 
- Should not be used in cases where there are multiple settings changes (2+ fields)

## Other Considerations

InlineEdit will move us closer towards allowing our customers to be able to edit and save from one place and not have to switch between page views to edit information (single page application). It is important to consider how this component will work with existing and future edit and save patterns the future. As part of this work, we explored existing and future edit patterns that will need to be considered as part of implementation of this component.

### Existing Patterns

**Create Pattern:** InlineEdit will not be used in a **create new** context. We will continue to use our current Form component and single layout page view for first time create. This applies to client, properties and objects.

**Modal Edit:** We will continue using Modal editing for global settings (information that will change across the product such as client and property information) and/or if the information to be edited has a more complex interface than can be shown on a preview state (e.g. notification templates and business hours)

### New InlineEdit Patterns
**Default InlineEdit:** This proposal is for the smallest iteration of InlineEdit which includes a default setting. This will be used for small, single input data changes that have a default setting built in and allows quick changes in a view state.

**Multiline InlineEdit:** A Multiline InlineEdit will be used for input changes that do not require defaults and generally require more than a single data change. It will be used for InputText only. If a **read** state is required then it will read ‘None’. This can be used in external and internal facing notes.

**Bulk InlineEdit:** Bulk InlineEdit will be used for groups of 2+ related inputs that can be changed at once and do not affect global settings (information that has been created on the client or propoerty and exists in mulitple locations). This component should only be used if the **read** and **edit** view are similar in size and layout, do not take up more space between the two views and/or if the information has already been specified in a global form setting (e.g. custom fields on objects, line items)


## Content Guidelines

<!--
  What type of content does this component present (documents, text, images, other components)?
  What is the recommended, or expected, amount of content? What is the components’ behaviour when
  the provided content diverges from what is expected (image aspect ratio, amount of text, video
  vs audio, filesize)? Are there any important references to the [Product Vocabulary](https://atlantis.getjobber.com/guides/product-vocabulary)
  that should be made regarding this component? What happens when content is unavailable or unreliable
  (poor connection, empty states, flaky GPS data?)
-->

The InlineEdit component will be used to present content to a user that has small, single input default settings. It can be used with the following components InputText, InputTime, InputSelect, InputNumber. It is recommended that data be kept to a single numerical character or text (e.g. there should never be a sentence inside of an InlineEdit component for InputText)

If content is not required, or is empty, use a sensible placeholder value. The default value if none is provided or required can be “None”
 

## Accessibility

<!--
  Describe the accessibility concerns for the component. How does it handle touch vs cursor vs
  keyboard events? Should it capture input? What should a screen reader see when it's focuse?
-->

For the Inline Edit **read** state:
- User should be able to tab into the InputEdit and the field should then focus
- The second tab key should take the user out of the InputEdit field and onto the next focusable element on the page
- Pressing the ENTER key on the InputEdit component converts the component into the ‘Edit’ state

For the Inline Edit **edit** state
- User should be able to tab between the Input field and the action buttons (save and cancel)
- Arrow navigation also takes the user between the Input field and the action buttons
- Pressing the ENTER key in the **edit** state will save the data entered
- Pressing the Escape key exits the **edit** state, places the user back in the **read** state and keeps them on the InlineEdit component

AriaLabels must be present for the **save** and **cancel** buttons

## Responsiveness

<!--
  How should the component behave on an iPhone 8? An iPad? A 1920x1080 monitor? How does the
  component appear when the component itself is less than 375px wide? Less than 640px wide?
  Less than 1200px wide? Greater than 1200px? Does it change when the device DPI is higher
  or lower?
-->

Any copy that follows the InlineEdit component should be pushed to the right when the InlineEdit component goes into **edit** state. For small screen sizes, the text should truncate to a second line and the component should always remain inline.

![image](https://user-images.githubusercontent.com/49729186/114600801-ffa1a600-9c51-11eb-8a59-de34d1165536.png)

If the input is on the far right side of it's container while in **read** state, the controls should re-flow beneath the input on **edit** state to avoid a jarring reflow.

![image](https://user-images.githubusercontent.com/49729186/114600825-05978700-9c52-11eb-8e0b-f0329beecf3d.png)

## Mockup

<iframe
  style="border: 1px solid rgba(0, 0, 0, 0.1);"
  width="800"
  height="450"
  src="https://www.figma.com/file/nStDVM7Uir50rrDz5T9CLp/Design-System-Contribution-Inline-Edit?node-id=26%3A2"
  allowfullscreen
></iframe>

<!--
  Insert a Figma mockup from the [Design System Contribution template](https://www.figma.com/file/3BXCXXD9glMtj8RAHjXiQC/Design-System-Contribution-TEMPLATE?node-id=26%3A2)
  that conveys the visual design of the component, with variants and state accounted for.
  Consider progressive enhancement; might this rely on newer browser features that aren’t
  widely supported yet?
-->

[Figma Proposal](https://www.figma.com/file/nStDVM7Uir50rrDz5T9CLp/Design-System-Contribution-Inline-Edit?node-id=26%3A2)

## Notes
<!--
  What decisions worth remembering have gone into this component? Did we consider any potentially valuable
  functionality that we’re not implementing right now for scope purposes? Are there any design decisions
  that might need explaining beyond the usage guidelines? This will help consumers understand this component
  more fully.
-->
See usage guidelines

## Other Design Libraries

- [Atlassian InlineEdit](https://atlassian.design/patterns/inline-edit)
- [Anvil InlineEdit](https://anvil.servicetitan.com/components/inline-edit/)


